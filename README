~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
最优序列：原始序列或者衍生序列得到的优先级最大的元素组成的序列
原始序列：随机生成的序列，元素的个数为1024.
衍生序列：原始序列根据MR得到的序列

关蜕变关系的理解与实现：
MR1：比较原始序列与置换后的衍生序列的最优序列。实现：在原始序列的基础上随机产生一个置换序列
MR2：将原始序列分成两个部分：v和w。改变v和w的串联顺序，观察结果。实现：在原始序列的基础上随机产生一个位置，将原始序列分为两个部分v和w。衍生序列为wv。
MR3：在原始序列后面串联k个原始序列。实现：k值在[1-10]之间随机产生
MR4：在原始序列的后面串联一个原始序列的子集。实现：随机产生一个长度在1-1024之间的子序列
MR5：在原始序列后面添加一个最有序列的元素。实现：随机在最有序列中选择一个元素
MR6：在原始序列后面串联k个最有序列的子集。实现：：子集元素的个数分别为最优子集的1/10，3/10，5/10，7/10，10/10
MR7：在原始最优序列中插入一个介于两个最优序列之间的元素。实现：在最优序列中找到相邻的两个元素：不相等并且相差大于1，然后在这两个元素之间娶一个值
MR8：在原始序列后面串联一个子序列，子序列的长度为1-10(随机产生)。该子序列的最小元素都比原始最有序列中的最小值都小。实现：负数。（mr8实现不了：原因：一般序列都是有0的因此做不到，如果插入负数就会导致下标越界）
MR9：在原始序列后面串联一个子序列，该子序列的最小元素都比原始最优序列的最大值都大。实现：随机产生大于原始最优值的最大值的子序列。子序列的长度为最优子集的1/10，3/10，5/10，7/10，10/10
MR10：在原始序列后面串联一个最优序列的置换序列。实现：子序列分别为：和原始最优相同、相反以及随机置换两个元素
MR11：在原始序列前面串联一个最优序列的置换序列。实现：子序列分别为：和原始最优相同、相反以及随机置换两个元素
MR12：x序列得长度为10-1024之间。
MR13：理解：原始序列经过函数f作用后，与原始最优序列经同样的函数作用后的序列相同。实现：函数为f=x+1.

splitting:
MR14-17前提：假设原始序列V可以分为两个子序列v1,v2的串联。每一个蜕变关系的v1和v2是不一样的。

MR14：原始最优序列是两个子序列的最优序列的并集。实现：随机一个数将原始序列分成两个子序列v1和v2
MR15：实现同14
MR16：实现同14
MR17：实现同14
sublist:
MR18：实现：较大值固定为10，较小的分别取值为：1，3，6，9
MR19:实现：较大值固定为10，较小的分别取值为：1，3，6，9
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
原始序列的产生与存放：
原始序列：一共10个，序列的大小都是1024，均是随机产生，随机数种子分别是(1-10)。每一个序列经根据19个MR分别产生相应的衍生序列，然后分别执行。重复5次。
原始序列存放在datafile文件中的txt文件中以dataX命名，例如:dataOne.txt,对每一个元素设置优先级之后的数据存放在xml中对应的名字为dataX.xml。
返回的最有序列的个数设置为10。

XML文件的数据：根节点为data,序列中的元素从0-最大值进行编号，将编号作为element的属性，element的子节点为：item和priority分别存放相应的值。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
记录的日志格式(保存在excel文件中)：
第n次实验：
sourcelist | loopNumber | MR | mutants | killed mutants | numberOfkilled |residual mutants | time

一个序列根据某一个MR对所有的待测对象进行测试重复10次然后遍历所有的序列进行测试。
期间需要统计每一次测试的具体内容，并做好记录：1，对于某一个SUT10个原始序列在19个MR下能杀死的变异体有多少(记录每一个MR检测的变异体名字，然后汇总)
                                        2，对于每一个变异体能可以由几个MR检测出来(也可以从1中的记录中提取)
                                        3，每一次测试的时间(excel表中记录)指的是一个序列在某一个MR下在所有的变异体上测试的时间
                                        4，每一个MR可以检测出多少变异体(从1中的记录提取)
                                        5，哪些变异体检测不出来(从1中的记录中提取)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
错误报告(将某一序列在19个MR的作用下揭示故障的具体内容保存在txt文档中)：

用Junit中的org.junit.runner.Result类收集信息，并将测试的执行结果写入文档中。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
原始代码根据errta文件进行了修改。
每一种优先级队列的多个返回值可能是相等的。在测试过程中通过实现线程的run()方法可以得到严格递增的最优序列

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
变异体
1：传统的变异体：
SimpleLinear:add方法有5个变异体，removeMin方法有30个
SimpleTree：add方法有15个变异体，removeMin方法有15个
SequentialHeap:add方法有86个变异体，removeMin有186个变异体
FineGrainedHeap：add方法有185个变异体，removeMin有241个变异体
PrioritySkiplist:add方法有138个变异体，findAndMarkMin方法有11个变异体
以上各个算法的变异体没有进行等价变异体排查。

2：并发程序的变异体：

SimpleLinear:add方法有 个变异体，removeMin方法有 个
SimpleTree：add方法有 个变异体，removeMin方法有 个
SequentialHeap:add方法有 个变异体，removeMin有 个变异体
FineGrainedHeap：add方法有 个变异体，removeMin有 个变异体
PrioritySkiplist:add方法有 个变异体，findAndMarkMin方法有 个变异体
























